#include <ncurses.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>

#include "parser.h"
#include "utils/list.h"
#include "todo_list.h"

List todo_list = list_new();
bool todo_list_modified = false;

bool export_template(FILE * file) {
  if (!file) return false;
  if (fprintf(file, "-- File generated by idea. Edit this file with caution.\n") <= 0) return false;
  if (fprintf(file, "-- Command structure:\n") <= 0) return false;
  if (fprintf(file, "-- clear all\n") <= 0) return false;
  if (fprintf(file, "-- add [ToDo Name]\n\n") <= 0) return false;
  return true;
}

void free_todo(Todo *todo) {
  free(todo->data);
  if (todo->notes_filename) free(todo->notes_filename);
  free(todo);
}

bool remove_todo_notes(Todo *todo) {
  if (todo->notes_filename) {
    char *notes_directory = get_path_from_variable("HOME", CONFIG_PATH NOTES_FOLDER);
    char *path = concatenate_paths(notes_directory, todo->notes_filename);
    free(notes_directory);

    int remove_ret = remove(path);
    free(path);
    if (remove_ret == -1) return false;

    free(todo->notes_filename);
    todo->notes_filename = NULL;
  }
  return true;
}

/// FILE OPERATIONS
char *concatenate_paths(const char *directory, const char *relative) {
  unsigned int directory_length = strlen(directory);
  unsigned int relative_length = strlen(relative);

  char *full_path = NULL;
  if (directory[directory_length-1] == '/') {
    full_path = malloc(directory_length + relative_length + 1);
    if (!full_path) return NULL;
    strcpy(full_path, directory);
    strcat(full_path, relative);
  } else {
    full_path = malloc(directory_length + 1 + relative_length + 1);
    if (!full_path) return NULL;
    sprintf(full_path, "%s/%s", directory, relative);
  }
  return full_path;
}

char *get_path_from_variable(const char *variable, const char *path_from_directory) {
  const char *directory_path = getenv(variable);
  if (!directory_path) return NULL;

  return concatenate_paths(directory_path, path_from_directory);
}

bool save_string_to_binary_file(FILE *file, char *str) {
  if (!file) return false;
  unsigned int size = (str) ? strlen(str)+1 : 0;
  if (fwrite(&size, sizeof(unsigned int), 1, file) != 1) return false;
  if (size && fwrite(str, size, 1, file) != 1) return false;
  return true;
}

bool load_string_from_binary_file(FILE *file, char **str) {
  if (!file || !str) return false;
  unsigned int size;
  if (fread(&size, sizeof(unsigned int), 1, file) != 1) return false;
  if (size) {
    *str = malloc(size);
    if (fread(*str, size, 1, file) != 1) return false;
  } else {
    *str = NULL;
  }
  return true;
}

bool save_todo_to_binary_file(FILE *file, Todo *todo) {
  if (!save_string_to_binary_file(file, todo->data)) return false;
  if (!save_string_to_binary_file(file, todo->notes_filename)) return false;
  return true;
}

void *load_todo_from_binary_file(FILE *file) {
  Todo *todo = malloc(sizeof(Todo));
  if (!todo) abort();
  if (!load_string_from_binary_file(file, &todo->data)) return false;
  if (!load_string_from_binary_file(file, &todo->notes_filename)) return false;
  return todo;
}

bool save_todo_notes_to_text_file(FILE *save_file, Todo *todo) {
  if (!todo || !save_file) return false;
  if (!todo->notes_filename) return true;

  char *notes_directory = get_path_from_variable("HOME", CONFIG_PATH NOTES_FOLDER);
  char *path = concatenate_paths(notes_directory, todo->notes_filename);
  free(notes_directory); notes_directory = NULL;

  FILE *notes = fopen(path, "r");
  free(path); path = NULL;
  if (!notes) return false;

  if (fputs("notes_content ", save_file) == EOF) { fclose(notes); return false; }
  int c;
  while ( (c = fgetc(notes)) != EOF ) {
    if (c == '\n') {
      if (fputs("\\n", save_file) == EOF) { fclose(notes); return false; }
    } else {
      if (fputc(c, save_file) == EOF) { fclose(notes); return false; }
    }
  }
  fputc('\n', save_file);

  fclose(notes);
  return true;
}

bool save_todo_to_text_file(FILE *file, Todo *todo) {
  if (fprintf(file, "add %s\n", todo->data) <= 0) return false;
  if (!save_todo_notes_to_text_file(file, todo)) return false;
  return true;
}

bool save_file() {
  char *path = get_path_from_variable("HOME", CONFIG_PATH SAVE_FILENAME);
  FILE *save_file = fopen(path, "wb");
  free(path);
  if (!save_file) return false;

  if (!list_save_to_bfile(todo_list, (bool (*)(FILE *, void *)) save_todo_to_binary_file, save_file)) {
    fclose(save_file);
    return false;
  }

  fclose(save_file);
  return true;
}

bool create_dir_if_not_exists(char *dir_path) {
  struct stat st = {0};
  if (stat(dir_path, &st) != -1) return (S_ISDIR(st.st_mode));
  return (mkdir(dir_path, 0755) == 0);
}

bool create_dir_structure() {
  List paths = list_new();

  list_append(&paths, get_path_from_variable("HOME", CONFIG_PATH));

  char *notes_path = get_path_from_variable("HOME", CONFIG_PATH NOTES_FOLDER);
  notes_path[strlen(notes_path) - 1] = '\0'; // Remove the "/" at the end
  list_append(&paths, notes_path);

  while (!list_is_empty(paths)) {
    char *path = list_remove(&paths, 0);

    if (!create_dir_if_not_exists(path)) {
      printf("Unable to create the directory %s\n", path);
      free(path);
      list_destroy(&paths, free);
      return false;
    }
    free(path);
  }
  return true;
}

bool load_file() {
  if (!list_is_empty(todo_list)) abort();

  if (!create_dir_structure()) return false;

  char *path = get_path_from_variable("HOME", CONFIG_PATH SAVE_FILENAME);
  FILE *save_file = fopen(path, "rb");
  free(path);
  if (!save_file) return true; // First time running it

  if (!list_load_from_bfile(&todo_list, load_todo_from_binary_file, save_file)) abort();

  fclose(save_file);
  return true;
}

/// Functionality
Action_return action_add_todo(Input *input) {
  Todo *new = malloc(sizeof(Todo));
  if (!new) return ACTION_RETURN(RETURN_ERROR_AND_EXIT, "No more memory");
  new->notes_filename = NULL;
  new->data = next_token(input, 0);
  if (!new->data) {
    free(new);
    return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  }
  list_append(&todo_list, new);
  return ACTION_RETURN(RETURN_SUCCESS, "");
}

Action_return action_remove_todo(Input *input) {
  char *pos_str = next_token(input, 0);
  if (!pos_str) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  unsigned int pos = atoi(pos_str);
  free(pos_str);

  if (pos == 0 || pos > list_size(todo_list)) return ACTION_RETURN(RETURN_ERROR, "Invalid Position");

  Todo *todo = list_remove(&todo_list, pos-1);

  if (!remove_todo_notes(todo)) {
    list_insert_at(&todo_list, todo, pos-1);
    return ACTION_RETURN(RETURN_ERROR, "Unable to remove the ToDo's notes file (inside ~/" CONFIG_PATH NOTES_FOLDER ")");
  }

  free_todo(todo);
  return ACTION_RETURN(RETURN_SUCCESS, "");
}

Action_return action_move_todo(Input *input) {
  char *pos_origin_str = next_token(input, ' ');
  if (!pos_origin_str) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  unsigned int pos_origin = atoi(pos_origin_str);
  free(pos_origin_str);

  char *pos_destination_str = next_token(input, 0);
  if (!pos_destination_str) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  unsigned int pos_destination = atoi(pos_destination_str);
  free(pos_destination_str);

  if (pos_origin == 0 || pos_origin > list_size(todo_list)) return ACTION_RETURN(RETURN_ERROR, "Invalid origin position");
  if (pos_destination == 0 || pos_destination > list_size(todo_list)) return ACTION_RETURN(RETURN_ERROR, "Invalid destination position");
  if (pos_destination == pos_origin) return ACTION_RETURN(RETURN_INFO, "Moving to the same position");

  Todo *todo = list_remove(&todo_list, pos_origin-1);
  // if (pos_origin < pos_destination) pos_destination--;
  list_insert_at(&todo_list, todo, pos_destination-1);
  return ACTION_RETURN(RETURN_SUCCESS, "");
}

Action_return action_edit_todo(Input *input) {
  char *pos_str = next_token(input, ' ');
  if (!pos_str) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  unsigned int pos = atoi(pos_str);
  free(pos_str);

  if (pos == 0 || pos > list_size(todo_list)) return ACTION_RETURN(RETURN_ERROR, "Invalid Position");

  char *new_text = next_token(input, 0);
  if (!new_text) return ACTION_RETURN(RETURN_ERROR, "Empty new text.");

  Todo *todo = list_get(todo_list, pos-1);
  free(todo->data);
  todo->data = new_text;
  return ACTION_RETURN(RETURN_SUCCESS, "");
}

Action_return action_clear_todos(Input *input) {
  char *confirmation = next_token(input, 0);
  if (!confirmation) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  if (strcmp(confirmation, "all")) {
    free(confirmation);
    return ACTION_RETURN(RETURN_ERROR, "Specify 'all' as the first argument to clear all the ToDos");
  }
  free(confirmation);

  if (!list_map_bool(todo_list, (bool (*)(void *))remove_todo_notes)) return ACTION_RETURN(RETURN_ERROR, "Unable to remove a ToDo's notes file");
  list_destroy(&todo_list, (void (*)(void *))free_todo);
  return ACTION_RETURN(RETURN_SUCCESS, "");
}

Action_return action_notes_todo_remove(Input *input) {
  char *pos_str = next_token(input, 0);
  if (!pos_str) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  unsigned int pos = atoi(pos_str);
  free(pos_str);
  if (!pos) return ACTION_RETURN(RETURN_ERROR, "The given position is not a number");
  if (pos == 0 || pos > list_size(todo_list)) return ACTION_RETURN(RETURN_ERROR, "Invalid position");
  Todo *todo = list_get(todo_list, pos-1);

  if (!todo->notes_filename) return ACTION_RETURN(RETURN_INFO, "The todo doesn't have a notes file");
  if (!remove_todo_notes(todo)) return ACTION_RETURN(RETURN_ERROR, "Unable to remove the notes");
  return ACTION_RETURN(RETURN_SUCCESS, "");
}

Action_return action_notes_todo_create(Input *input) {
  char *pos_str = next_token(input, 0);
  if (!pos_str) return ACTION_RETURN(RETURN_ERROR, "Command malformed");
  unsigned int pos = atoi(pos_str);
  free(pos_str);
  if (!pos) return ACTION_RETURN(RETURN_ERROR, "The given position is not a number");
  if (pos == 0 || pos > list_size(todo_list)) return ACTION_RETURN(RETURN_ERROR, "Invalid position");
  Todo *todo = list_get(todo_list, pos-1);

  if (!todo->notes_filename) {
    char *path = get_path_from_variable("HOME", CONFIG_PATH NOTES_FOLDER NOTES_TEMPLATE);
    int fd = mkstemps(path, 3);
    if (fd == -1) return ACTION_RETURN(RETURN_ERROR, "Unable to create the file for the notes!");

    const unsigned int path_length = strlen(getenv("HOME")) + 1 /* '/' */ + strlen(CONFIG_PATH) + strlen(NOTES_FOLDER);
    const unsigned int name_length = strlen(NOTES_TEMPLATE);

    todo->notes_filename = malloc(name_length+1);
    memcpy(todo->notes_filename, path + path_length, name_length);
    todo->notes_filename[name_length] = '\0';
    free(path);

    if (!write(fd, "# ", 2)
        || !write(fd, todo->data, strlen(todo->data))
        || !write(fd, "\n\n\n", 3)
       ) {
         close(fd);
         remove_todo_notes(todo);
         return ACTION_RETURN(RETURN_ERROR, "Unable to write to the notes files");
    }

    close(fd);
    return ACTION_RETURN(RETURN_SUCCESS, "");
  } else {
    return ACTION_RETURN(RETURN_INFO, "Already exists a notes file for this todo");
  }
}

Functionality todo_list_functionality[] = {
  { "add", "a", action_add_todo, MAN("Add a ToDo", "[name]") },
  { "remove", "rm", action_remove_todo, MAN("Remove a ToDo", "[ID]") },
  { "move", "mv", action_move_todo, MAN("Move ToDo", "[ID]") },
  { "edit", "e", action_edit_todo, MAN("Edit a ToDo", "[ID] [new name]") },
  { "clear", NULL, action_clear_todos, MAN("Clear all ToDos", "all") },
  { "notes_create", NULL, action_notes_todo_create, MAN("Create the notes file for the todo if it doesn't already exist", "[ID]") }, // The opening of the todo is delegated to each interface
  { "notes_remove", NULL, action_notes_todo_remove, MAN("Remove the notes file for the todo", "[ID]") },
};
unsigned int todo_list_functionality_count = sizeof(todo_list_functionality) / sizeof(Functionality);
